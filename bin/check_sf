#!/usr/bin/env node

var async = require('async');
var cli = require('cli');
var colors = require('colors');
var fs = require('fs');
var argv = require('optimist').usage('Usage: $0 -qo').boolean('q').boolean('o').argv;

colors.setTheme({
	help: 'cyan',
	warn: 'yellow',
	error: 'red',
	subtle: 'grey'
});

var args = argv._;

var INDENT = '    ';

var QUIET = argv.q;

var REGEX_EXT_CSS = /\.(s)?css$/;
var REGEX_EXT_HTML = /\.(jsp.?|html|vm|ftl)$/;
var REGEX_EXT_JS = /\.js$/;

var REGEX_LEADING_SPACE = /^\s+/;
var REGEX_PROP_KEY = /^\s*([^:]+)(?:)/;

var REGEX_PROPERTY = /^\t*[^:]+:[^;]+;$/;
var REGEX_SUB = /\{\s*([^|}]+?)\s*(?:\|([^}]*))?\s*\}/g;
// var REGEX_ZERO_UNIT = /\b0(?!s\b)[a-zA-Z]{1,}\b/;
var REGEX_ZERO_UNIT = /(#?)(\b0(?!s\b)[a-zA-Z]{1,}\b)/;
var REGEX_HEX_REDUNDANT = /#([0-9A-Fa-f])\1([0-9A-Fa-f])\2([0-9A-Fa-f])\3/;
var REGEX_HEX_LOWER = /[a-f]/;
var REGEX_HEX = /#[0-9A-Fa-f]{3,6}/;

var REGEX_MIXED_SPACES = /^.*( \t|\t ).*$/;

var REPLACE_REGEX_REDUNDANT = '#$1$2$3';

var hasProperty = function(item) {
	return REGEX_PROPERTY.test(item);
};

var hasLowerCaseRegex = function(item) {
	var match = item.match(REGEX_HEX);
	var lowerCaseRegex = false;

	if (match) {
		lowerCaseRegex = REGEX_HEX_LOWER.test(match);
	}

	return lowerCaseRegex;
};

var hasRedundantRegex = function(item) {
	return REGEX_HEX_REDUNDANT.test(item);
};

var hasNeedlessUnit = function(item) {
	var m = item.match(REGEX_ZERO_UNIT);

	return m && !m[1];
	// return REGEX_ZERO_UNIT.test(item);
};

var hasMixedSpaces = function(item) {
	return REGEX_MIXED_SPACES.test(item);
};

var fileErrors = {};

var trackErr = function(err, file) {
	var errors = fileErrors[file];

	if (!errors) {
		errors = [];

		fileErrors[file] = errors;
	}

	errors.push(err);
}

var sub = function(str, obj) {
	var objType = typeof obj;

	if (objType !== 'object' && objType !== 'function') {
		obj = Array.prototype.slice.call(arguments, 1);
	}

	return str.replace ? str.replace(REGEX_SUB, function(match, key) {
		return (typeof obj[key] !== 'undefined') ? obj[key] : match;
	}) : s;
};

var iterateLines = function(contents, iterator) {
	var lines = contents.split('\n');

	lines.forEach(iterator);
};

var checkCss = function(contents, file) {
	iterateLines(
		contents,
		function(item, index, collection) {
			var fullItem = item;

			item = item.trim();

			var lineNum = index + 1;
			var nextItem = collection[lineNum] && collection[lineNum].trim();

			if (hasProperty(item)) {
				item = item.replace(REGEX_LEADING_SPACE, '');

				var nextItemMatch;

				var itemMatch = item.match(REGEX_PROP_KEY);

				if (nextItem && hasProperty(nextItem)) {
					nextItem = nextItem.replace(REGEX_LEADING_SPACE, '');
					nextItemMatch = nextItem && hasProperty(nextItem) && nextItem.match(REGEX_PROP_KEY);
				}

				if (itemMatch && nextItemMatch) {
					if (itemMatch[0] > nextItemMatch[0]) {
						trackErr(sub('Line: {0} Sort: {1} {2}', lineNum, item, nextItem).warn, file);
					}
				}
			}

			var hexMatch = item.match(REGEX_HEX);

			if (hexMatch) {
				hexMatch = hexMatch[0];

				if (hasLowerCaseRegex(hexMatch)) {
					trackErr(sub('Line {0} Hex code should be all uppercase: {1}', lineNum, item).warn, file);
				}

				if (hasRedundantRegex(hexMatch)) {
					trackErr(sub('Line {0} Hex code can be reduced to {2}: {1}', lineNum, item, hexMatch.replace(REGEX_HEX_REDUNDANT, REPLACE_REGEX_REDUNDANT)).warn, file);
				}
			}

			if (hasNeedlessUnit(item)) {
				trackErr(sub('Line {0} Needless unit: {1}', lineNum, item).warn, file);
			}

			if (hasMixedSpaces(fullItem)) {
				trackErr(sub('Line {0} Mixed spaces and tabs: {1}', lineNum, item).warn, file);
			}
		}
	);
};

var checkJs = function(contents, file) {
	iterateLines(
		contents,
		function(item, index, collection) {
			var fullItem = item;

			item = item.trim();

			var lineNum = index + 1;

			if (hasMixedSpaces(fullItem)) {
				trackErr(sub('Line {0} Mixed spaces and tabs: {1}', lineNum, item).warn, file);
			}
		}
	);
};

var checkHTML = function(contents, file) {
	iterateLines(
		contents,
		function(item, index, collection) {
			var fullItem = item;

			item = item.trim();

			var lineNum = index + 1;

			var attrs = fullItem.match(/(?: )([A-Za-z0-9-]+=["'][^"']+["'])/g);

			if (attrs) {
				var lastAttr = -1;

				attrs.forEach(
					function(item, index, collection) {
						var pieces = item.trim().split('=');

						var attrName = pieces[0];
						var attrValue = pieces[1].trim().replace(/(^["']|["']$)/g, '');

						if (lastAttr > attrName) {
							var re = new RegExp('\\b' + lastAttr + '\\b.*?> ?<.*?' + attrName);

							var note = '';

							if (re.test(fullItem)) {
								note = '**'
							}

							trackErr(sub('Line {0} Sort attributes{3}: {1} {2}', lineNum, lastAttr, attrName, note).warn, file);
						}

						var attrValuePieces = attrValue.split(' ');

						var lastAttrPiece = -1;

						attrValuePieces.forEach(
							function(item, index, collection) {
								if (/^[A-Za-z]/.test(item)) {
									if (attrName.indexOf('on') !== 0 && lastAttrPiece > item) {
										trackErr(sub('Line {0} Sort attribute values: {1} {2}', lineNum, lastAttrPiece, item).warn, file);
									}

									lastAttrPiece = item;
								}
							}
						);

						lastAttr = attrName;
					}
				);
			}
		}
	);
};

var series = args.map(
	function(file) {
		return function(cb) {
			fs.readFile(file, 'utf-8', function (err, data) {
				if (err) {
					return cb(err);
				}

				if (REGEX_EXT_CSS.test(file)) {
					checkCss(data, file);
				}
				else if (REGEX_EXT_JS.test(file)) {
					checkJs(data, file);
				}
				else if (REGEX_EXT_HTML.test(file)) {
					checkHTML(data, file);
				}

				var errors = fileErrors[file] || [];

				var includeHeaderFooter = (errors.length || !QUIET);

				if (includeHeaderFooter) {
					console.log('File:'.blackBG + ' ' + file.underline);
				}

				if (errors.length) {
					console.log(INDENT + errors.join('\n' + INDENT));
				}
				else if (includeHeaderFooter) {
					console.log(INDENT + 'clear');
				}

				if (includeHeaderFooter) {
					console.log('----'.subtle);
				}

				cb();
			});
		}
	}
);

var callback = function() {};

if (argv.o) {
	callback = function(err, result) {
		var errorFiles = Object.keys(fileErrors);

		if (errorFiles.length) {
			cli.exec(
				'git config --get user.editor',
				function(res) {
					cli.exec(
						'open -a "' + res[0] + '" "' + errorFiles.join('" "') + '"'
					);
				}
			);
		}
	};
}

async.series(series, callback);